<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reinforcement Learning Grid World</title>
    <style>
        html {
            height: 100%;
            position: relative;
        }
        
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 10px 20px;
            min-height: 97vh;
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* Keep space-between for container and footer */
        }
        
        .container {
            flex: 0 1 auto; /* Changed from flex: 1 to prevent excessive stretching */
            display: flex;
            flex-direction: column;
            justify-content: flex-start; /* Keep flex-start to align content to top */
            align-items: center;
            min-height: auto; /* Changed from 70vh to auto */
            padding-bottom: 20px;
        }
        
        h1 {
            margin-bottom: 15px;
        }
        
        .controls {
            margin-bottom: 0px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .grid-container {
            flex-grow: 1; /* Allow the grid to grow and take available space */
            display: flex;
            flex-direction: row; /* Changed from column to row */
            justify-content: center;
            align-items: flex-start; /* Changed from center to flex-start */
            gap: 20px; /* Add gap between grid and legend */
            margin-bottom: 5px; /* Further reduced margin */
        }
        table {
            border-collapse: collapse;
        }
        td {
            border: 1px solid #ccc;
            width: 60px;
            height: 60px;
            text-align: center;
            position: relative;
            cursor: pointer;
        }
        .cell-content {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100%;
        }
        .start {
            background-color: #a0ffa0;
        }
        .end {
            background-color: #ffa0a0;
        }
        .obstacle {
            background-color: #808080;
        }
        .arrow {
            font-size: 24px;
            line-height: 1;
        }
        .value {
            font-size: 12px;
            margin-top: 3px;
        }
        .button {
            padding: 8px 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .button:hover {
            background-color: #45a049;
        }
        .button:disabled {
            background-color: #cccccc;
            color: #666666;
            cursor: not-allowed;
        }
        .status {
            margin-top: 10px; /* Reduced from 20px */
            margin-bottom: 10px; /* Added margin-bottom */
            font-style: italic;
            text-align: center; /* Add center alignment */
            font-size: 16px; /* Increased from default size */
            font-weight: 500; /* Added medium font weight for better visibility */
            height: 50px; /* Fixed height to accommodate approximately 3 lines */
            display: flex; /* Use flexbox for vertical alignment */
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
            overflow: hidden; /* Prevent overflow */
        }
        
        .status div {
            width: 100%; /* Ensure inner content takes full width */
        }
        
        .legend {
            margin-top: 0; /* Remove top margin */
            display: flex;
            flex-direction: column; /* Changed from row to column */
            justify-content: flex-start; /* Changed from center to flex-start */
            gap: 10px; /* Reduced gap for vertical layout */
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s ease;
            height: auto; /* Changed from fixed height to auto */
            align-items: flex-start; /* Changed from center to flex-start */
            padding: 10px; /* Add padding */
        }
        .legend.visible {
            visibility: visible;
            opacity: 1;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
        }
        .edit-controls {
            margin-top: 10px; /* Reduced from 15px */
            margin-bottom: 10px; /* Added margin-bottom */
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        .alert-message {
            color: red;
            font-weight: bold;
            animation: shake 0.5s;
        }
        
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            50% { transform: translateX(5px); }
            75% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        
        footer {
            margin-top: 0; /* Remove top margin since we're using space-between */
            padding: 15px;
            background-color: #f8f9fa;
            border-top: 1px solid #e9ecef;
            text-align: center;
            color: #6c757d;
            border-radius: 5px;
            width: 100%;
            flex-shrink: 0;
        }
        
        .footer-content {
            max-width: 800px;
            margin: 0 auto;
        }
        
        .footer-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #343a40;
        }
        
        .footer-info {
            font-size: 14px;
            line-height: 1.5;
        }
        
        .footer-github {
            margin-top: 10px;
        }
        
        .footer-github a {
            color: #28a745;
            text-decoration: none;
            transition: color 0.3s;
        }
        
        .footer-github a:hover {
            color: #218838;
            text-decoration: underline;
        }
        
        .footer-powered {
            margin-top: 10px;
            font-size: 12px;
            font-style: italic;
        }
        
        .info-block {
            background-color: #f0f8ff;
            border: 1px solid #d0e3ff;
            border-radius: 5px;
            padding: 10px;
            margin-top: 10px;
            margin-bottom: 10px;
            font-size: 14px;
            color: #333;
            width: 100%;
            max-width: 800px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Reinforcement Learning Grid World</h1>
        
        <div class="info-block" id="algorithmInfo">
            <h3>Algorithm Information:</h3>
            <ul>
                <li><strong>Random Policy</strong>: Generates a random policy (arrows) and evaluates how good it is.</li>
                <li><strong>Improve Policy</strong>: Takes the current policy and makes it better by choosing optimal actions.</li>
                <li><strong>Value Iteration</strong>: Directly computes the optimal policy using dynamic programming.</li>
            </ul>
        </div>
        
        <div class="controls">
            <label for="gridSize">Grid Size (5-9):</label>
            <input type="number" id="gridSize" min="5" max="9" value="5">
            <button id="createGridBtn" class="button">Create Grid</button>
            <button id="evaluateBtn" class="button" disabled>Random Policy</button>
            <button id="improveBtn" class="button" disabled>Improve Policy</button>
            <button id="valueIterationBtn" class="button" disabled>Value Iteration</button>
        </div>
        
        <div class="status" id="statusText">
            Please set grid size and create a grid to begin.
        </div>
        
        <div class="grid-container" id="gridContainer"></div>
        
        <div class="edit-controls">
            <button id="editBtn" class="button">Edit Grid</button>
            <button id="clearBtn" class="button">Clear All</button>
        </div>
    </div>
    
    <footer>
        <div class="footer-content">
            <div class="footer-title">
                NCHU CSE Deep Reinforcement Learning - HW1
            </div>
            <div class="footer-info">
                Name: Chen-Jui, Yu (游宸睿) | Student ID: 7113056013 | Department: Computer Science and Engineering, Master's Program
            </div>
            <div class="footer-github">
                <a href="https://github.com/Rui0828" target="_blank">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16" style="vertical-align: text-bottom; margin-right: 3px;">
                        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"/>
                    </svg>
                    GitHub: Rui0828
                </a>
            </div>
            <div class="footer-powered">
                Powered by Flask & JavaScript | &copy; 2025
            </div>
        </div>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // State variables
            let gridState = {
                size: 5,
                start: null,
                end: null,
                obstacles: [],
                policy: [],
                values: [],
                isLocked: false
            };
            
            let grid = []; // DOM elements for the grid cells
            
            const createGridBtn = document.getElementById('createGridBtn');
            const evaluateBtn = document.getElementById('evaluateBtn');
            const improveBtn = document.getElementById('improveBtn');
            const valueIterationBtn = document.getElementById('valueIterationBtn');
            const editBtn = document.getElementById('editBtn');
            const clearBtn = document.getElementById('clearBtn');
            const gridContainer = document.getElementById('gridContainer');
            const statusText = document.getElementById('statusText');
            let legend = document.querySelector('.legend'); // Get reference to legend
            const algorithmInfo = document.getElementById('algorithmInfo');
            
            // Initially hide the edit buttons
            editBtn.style.display = 'none';
            clearBtn.style.display = 'none';
            
            // Event handlers
            createGridBtn.addEventListener('click', initializeGrid);
            evaluateBtn.addEventListener('click', function(e) {
                if (!gridState.start || !gridState.end) {
                    e.preventDefault();
                    showWarning('Please set both start and end positions before generating a policy.');
                    return;
                }
                evaluatePolicy();
            });
            
            improveBtn.addEventListener('click', function(e) {
                if (!gridState.start || !gridState.end) {
                    e.preventDefault();
                    showWarning('Please set both start and end positions before improving the policy.');
                    return;
                }
                improvePolicy();
            });
            
            valueIterationBtn.addEventListener('click', function(e) {
                if (!gridState.start || !gridState.end) {
                    e.preventDefault();
                    showWarning('Please set both start and end positions before running value iteration.');
                    return;
                }
                runValueIteration();
            });
            
            editBtn.addEventListener('click', enableGridEditing);
            clearBtn.addEventListener('click', clearAll);
            
            // Initialize grid based on user input
            function initializeGrid() {
                const gridSizeInput = document.getElementById('gridSize');
                const size = parseInt(gridSizeInput.value);
                
                if (isNaN(size) || size < 5 || size > 9) {
                    alert('Please enter a grid size between 5 and 9');
                    return;
                }
                
                // Reset grid state
                gridState = {
                    size: size,
                    start: null,
                    end: null,
                    obstacles: [],
                    policy: [],
                    values: Array(size).fill().map(() => Array(size).fill(0)),
                    isLocked: false
                };
                
                // Create grid table
                createGridTable(size);
                
                // Show the legend when grid is created
                legend.classList.add('visible');
                
                // Update status
                statusText.textContent = 'Click on cells to set start (green), end (red), and obstacles (gray).';
                
                // Disable the evaluate button until start and end are set
                evaluateBtn.disabled = true;
                improveBtn.disabled = true;
                valueIterationBtn.disabled = true;
                
                // Show appropriate buttons
                evaluateBtn.disabled = true;
                improveBtn.disabled = true;
                valueIterationBtn.disabled = true;
                editBtn.style.display = 'none';
                clearBtn.style.display = 'none';
            }
            
            // Create HTML table for the grid
            function createGridTable(size) {
                grid = [];
                gridContainer.innerHTML = '';
                
                // Create table
                const table = document.createElement('table');
                
                for (let i = 0; i < size; i++) {
                    const row = document.createElement('tr');
                    const gridRow = [];
                    
                    for (let j = 0; j < size; j++) {
                        const cell = document.createElement('td');
                        const cellContent = document.createElement('div');
                        cellContent.className = 'cell-content';
                        cell.appendChild(cellContent);
                        
                        cell.dataset.row = i;
                        cell.dataset.col = j;
                        
                        cell.addEventListener('click', function() {
                            handleCellClick(parseInt(this.dataset.row), parseInt(this.dataset.col));
                        });
                        
                        row.appendChild(cell);
                        gridRow.push(cell);
                    }
                    
                    table.appendChild(row);
                    grid.push(gridRow);
                }
                
                gridContainer.appendChild(table);
                
                // Create legend in the grid container instead of outside
                const legendDiv = document.createElement('div');
                legendDiv.className = 'legend';
                
                // Create legend items
                const legendItems = [
                    { color: '#a0ffa0', text: 'Start' },
                    { color: '#ffa0a0', text: 'End' },
                    { color: '#808080', text: 'Obstacle' }
                ];
                
                legendItems.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'legend-item';
                    
                    const colorDiv = document.createElement('div');
                    colorDiv.className = 'legend-color';
                    colorDiv.style.backgroundColor = item.color;
                    
                    const textSpan = document.createElement('span');
                    textSpan.textContent = item.text;
                    
                    itemDiv.appendChild(colorDiv);
                    itemDiv.appendChild(textSpan);
                    legendDiv.appendChild(itemDiv);
                });
                
                gridContainer.appendChild(legendDiv);
                
                // Store reference to the newly created legend
                legend = legendDiv;
            }
            
            // Handle cell clicks to set start, end, and obstacles
            function handleCellClick(row, col) {
                // Don't allow edits if grid is locked
                if (gridState.isLocked) {
                    statusText.innerHTML = '<div class="alert-message">Grid is locked for editing. Click "Edit Grid" to modify the grid.</div>';
                    return;
                }
                
                const cell = grid[row][col];
                
                // If cell is already selected, unselect it
                if (cell.classList.contains('start')) {
                    cell.classList.remove('start');
                    gridState.start = null;
                    updateStatusText();
                    checkAndEnableButtons();
                    return;
                }
                
                if (cell.classList.contains('end')) {
                    cell.classList.remove('end');
                    gridState.end = null;
                    updateStatusText();
                    checkAndEnableButtons();
                    return;
                }
                
                if (cell.classList.contains('obstacle')) {
                    cell.classList.remove('obstacle');
                    gridState.obstacles = gridState.obstacles.filter(obs => 
                        obs.row !== row || obs.col !== col
                    );
                    updateStatusText();
                    return;
                }
                
                // Set new state based on current grid status
                if (gridState.start === null) {
                    gridState.start = { row, col };
                    cell.classList.add('start');
                } else if (gridState.end === null) {
                    gridState.end = { row, col };
                    cell.classList.add('end');
                } else {
                    // Check if adding another obstacle would exceed the limit
                    const maxObstacles = gridState.size - 2;
                    
                    if (gridState.obstacles.length >= maxObstacles) {
                        showWarning(`Maximum ${maxObstacles} obstacles allowed for a ${gridState.size}x${gridState.size} grid.`);
                        return;
                    }
                    
                    gridState.obstacles.push({ row, col });
                    cell.classList.add('obstacle');
                }
                
                updateStatusText();
                checkAndEnableButtons();
            }
            
            // Update status text based on current grid state
            function updateStatusText() {
                if (gridState.start === null) {
                    statusText.textContent = 'Click a cell to set the start position (green).';
                } else if (gridState.end === null) {
                    statusText.textContent = 'Click a cell to set the end position (red).';
                } else {
                    const maxObstacles = gridState.size - 2;
                    const remainingObstacles = maxObstacles - gridState.obstacles.length;
                    
                    if (remainingObstacles > 0) {
                        statusText.textContent = `Click cells to add obstacles (gray). ${remainingObstacles} obstacles remaining. Click again to remove. When ready, click "Random Policy".`;
                    } else {
                        statusText.textContent = 'Maximum number of obstacles reached. Click on obstacles to remove them. When ready, click "Random Policy".';
                    }
                }
            }
            
            // Enable buttons if start and end are set
            function checkAndEnableButtons() {
                const buttonsEnabled = gridState.start !== null && gridState.end !== null;
                evaluateBtn.disabled = !buttonsEnabled;
                improveBtn.disabled = !buttonsEnabled;
                valueIterationBtn.disabled = !buttonsEnabled;
            }
            
            // Lock grid after policy display
            function lockGrid() {
                gridState.isLocked = true;
                
                // Show edit and clear buttons
                editBtn.style.display = 'inline-block';
                clearBtn.style.display = 'inline-block';
                
                // Keep all policy buttons enabled
                evaluateBtn.disabled = false;
                improveBtn.disabled = false;
                valueIterationBtn.disabled = false;
                
                // Don't append lock message here
            }
            
            // Enable grid editing
            function enableGridEditing() {
                console.log("Edit Grid button clicked"); // Add debugging
                gridState.isLocked = false;
                
                // Clear policy display but keep grid settings
                for (let i = 0; i < gridState.size; i++) {
                    for (let j = 0; j < gridState.size; j++) {
                        const cell = grid[i][j];
                        const content = cell.querySelector('.cell-content');
                        content.innerHTML = '';
                    }
                }
                
                // Reset policy and values arrays but keep grid configuration
                gridState.policy = [];
                gridState.values = Array(gridState.size).fill().map(() => Array(gridState.size).fill(0));
                
                // Hide edit buttons, enable policy buttons
                editBtn.style.display = 'none';
                clearBtn.style.display = 'none';
                
                // Re-enable policy buttons if start and end are set
                checkAndEnableButtons(); // Replace the if-statement with this function call
                
                statusText.textContent = 'Grid is now editable. You can modify start, end, and obstacles.';
            }
            
            // Clear all and start fresh
            function clearAll() {
                console.log("Clear All button clicked"); // Add debugging
                const size = gridState.size;
                gridState = {
                    size: size,
                    start: null,
                    end: null,
                    obstacles: [],
                    policy: [],
                    values: Array(size).fill().map(() => Array(size).fill(0)),
                    isLocked: false
                };
                
                // Recreate grid table
                createGridTable(size);
                
                // Show legend since grid will be displayed
                legend.classList.add('visible');
                
                // Reset UI buttons
                editBtn.style.display = 'none';
                clearBtn.style.display = 'none';
                evaluateBtn.disabled = true;
                improveBtn.disabled = true;
                valueIterationBtn.disabled = true;
                
                statusText.textContent = 'Grid cleared. Click on cells to set start (green), end (red), and obstacles (gray).';
            }
            
            // Generate random policy and evaluate it
            function evaluatePolicy() {
                statusText.textContent = 'Generating random policy and evaluating...';
                
                // First call API to create a grid with random policy
                fetch('/api/grid', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ n: gridState.size })
                })
                .then(response => response.json())
                .then(data => {
                    gridState.policy = data.policy;
                    
                    // Then evaluate the policy
                    return fetch('/api/evaluate', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(gridState)
                    });
                })
                .then(response => response.json())
                .then(data => {
                    gridState.values = data.values;
                    updateGridDisplay();
                    statusText.innerHTML = '<div style="text-align:center">Random policy generated and evaluated.<br>You can click "Improve Policy" to optimize it or use "Value Iteration" to find the optimal policy directly.</div>';
                    lockGrid();
                })
                .catch(error => {
                    console.error('Error:', error);
                    statusText.textContent = 'Error generating random policy. Check console for details.';
                });
            }
            
            // Improve the current policy
            function improvePolicy() {
                // Don't allow policy improvement if there's no policy to improve
                if (!gridState.policy || gridState.policy.length === 0) {
                    statusText.textContent = 'Please generate a random policy first before improving.';
                    return;
                }
                
                statusText.textContent = 'Improving policy...';
                
                fetch('/api/improve', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(gridState)
                })
                .then(response => response.json())
                .then(data => {
                    gridState.policy = data.policy;
                    gridState.values = data.values;
                    updateGridDisplay();
                    statusText.textContent = 'Policy improved. The arrows show the optimal action in each state.';
                    // Don't call lockGrid() again as the grid is already locked
                })
                .catch(error => {
                    console.error('Error:', error);
                    statusText.textContent = 'Error improving policy. Check console for details.';
                });
            }
            
            // Run value iteration to find optimal policy
            function runValueIteration() {
                statusText.textContent = 'Running value iteration...';
                
                fetch('/api/value-iteration', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(gridState)
                })
                .then(response => response.json())
                .then(data => {
                    gridState.policy = data.policy;
                    gridState.values = data.values;
                    updateGridDisplay();
                    statusText.textContent = 'Value iteration complete. The arrows show the optimal policy.';
                    // Lock grid if not already locked
                    if (!gridState.isLocked) {
                        lockGrid();
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    statusText.textContent = 'Error running value iteration. Check console for details.';
                });
            }
            
            // Update grid display with policy arrows and values
            function updateGridDisplay() {
                for (let i = 0; i < gridState.size; i++) {
                    for (let j = 0; j < gridState.size; j++) {
                        const cell = grid[i][j];
                        const content = cell.querySelector('.cell-content');
                        
                        // Clear existing content
                        content.innerHTML = '';
                        
                        // Skip if cell is start, end or obstacle
                        if (
                            (gridState.start && gridState.start.row === i && gridState.start.col === j) ||
                            (gridState.end && gridState.end.row === i && gridState.end.col === j) ||
                            gridState.obstacles.some(obs => obs.row === i && obs.col === j)
                        ) {
                            continue;
                        }
                        
                        // Add policy arrow
                        const arrowDiv = document.createElement('div');
                        arrowDiv.className = 'arrow';
                        
                        if (gridState.policy && gridState.policy[i] && gridState.policy[i][j]) {
                            const policy = gridState.policy[i][j];
                            let arrow = '•';
                            
                            if (policy === 'up') arrow = '↑';
                            else if (policy === 'down') arrow = '↓';
                            else if (policy === 'left') arrow = '←';
                            else if (policy === 'right') arrow = '→';
                            
                            arrowDiv.textContent = arrow;
                        }
                        content.appendChild(arrowDiv);
                        
                        // Add state value
                        if (gridState.values && gridState.values[i] && gridState.values[i][j] !== undefined) {
                            const valueDiv = document.createElement('div');
                            valueDiv.className = 'value';
                            valueDiv.textContent = gridState.values[i][j].toFixed(2);
                            content.appendChild(valueDiv);
                        }
                    }
                }
            }
            
            // Show warning in status text with red color and shake animation
            function showWarning(message) {
                statusText.innerHTML = `<div class="alert-message">${message}</div>`;
            }
        });
    </script>
</body>
</html>
